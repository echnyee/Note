# 5
#系统设计  #分布式 #多进程
## [[分布式]]
# 24
#mongo #数据库
## mongo的分批加载
### batchsize
db.col.find({ score: { $gt: 100 } }).batchSize(100)
这个命令我理解会返回一个流控制器cursor
此时每次获取数据会被batchSize(100)限制，也就是流上限会被限制
```
MongoCursor<Document> cursor =
    collection.find(gt("score", 100))
              .batchSize(100)
              .iterator();

while (cursor.hasNext()) {
    Document doc = cursor.next();
}
```
类似这种处理
如果直接find，mongo也会有某种意义的上限，例如单个文档16mb
但这时 client buffer 可能瞬间暴涨
所以find+batchSize比find应该永远是更安全的
只是数据量不大的情况下，直接用find也没问题
不过这个也有问题，就是没法中断，不能说我先读了一些，然后进程去做点别的业务，等会儿再回来继续
### Skip
另外一个是skip，这个是分页加载，拿数据的时候跳掉前面的100个
db.collection
  .find({})
  .skip(100)
  .limit(10)
这个其实不太用，数据量大的时候会很慢
### 人工游标
然后我当时用的就是，人工游标，通过score + \_id，缩小了范围，也消除了重复性，也可以等会儿回来继续处理。
# 25
#锁 #多线程
n++，在操作系统层面，会读取内存数据到寄存器，寄存器+1，再写回内存
## atomic
用锁，可以避免多线程的竞争，让每次只有一个线程在做这个操作
atomic感觉有些类似，不过是操作系统层面的实现，可以让上面这3步变成一次操作，
2个atomic之间会互斥，不能同时进行。
## mutex
mutex的唤醒有2种机制
一种自旋，不停的试，知道获取到锁为止
一种是futex等待队列，线程进入到内核态等待，同时放入一个mutex对应的等待队列中，这样后续unlock的时候知道要唤醒谁
现实中很可能是混合的，先自旋一会儿，不行就进入内核态等待
## condition_variable
条件变量，更主要的是用于线程间通信，可以告诉另外一个线程可以开始后续的操作了
mutex也有通知的机制，但是他只是说这个锁可以持有了，不代表真的有事情可以做了
例如一个消息队列，里面是否有数据，有数据才会继续进行操作，这个就适合用条件变量
这个条件变量可以来回变。mutex就是一个锁，也没有值，只适合用于互斥。
条件变量是一个通知，就是线程A在等待条件变量满足条件，例如dataReady从false变成true
线程B会去写dataReady，写完之后唤醒线程A
## semaphore
信号量，这个还不够理解，粗浅的理解是控制资源数量的，同时有多少线程可以进入临界区进行操作。
# 26
#debug #登录 
定位登录问题，客户端会提示[数据库错误]角色反序列化失败
```
2025-12-26 14:42:58,260187 - logic_0 - 881319 - ERROR - 694E2E720002F4EB - [doraemon] lua_entity_manager.cpp:522 - load entity error, can not load entity data: AvatarActor(aSAuWHcaoSpEJH2e)

2025-12-26 14:42:58,260334 - logic_0 - 881319 - INFO - 694E2E720002F4EB - [**script] Account.lua:1457 - [id: aU4uXjvR63K0FKfU(137438953609) account: UIAutoTest] [CreateAvatarDBCallBack]Error=create entity from db failed, can not find entity, AvatarID:aSAuWHcaoSpEJH2e, RoleID:aSAuWHcaoSpEJH2e 1

2025-12-26 14:42:58,260490 - logic_0 - 881319 - INFO - 694E2E720002F4EB - [**script] Account.lua:2285 - [id: aU4uXjvR63K0FKfU(137438953609) account: UIAutoTest] ChangeLoginState 1002 CREAT_AVATAR_FROM_DB_START --> 1003 CREAT_AVATAR_FROM_DB_SUCESS

2025-12-26 14:42:58,262429 - logic_0 - 881319 - ERROR - 694E2E720002F4EB - [**script] Account.lua:1468 - [id: aU4uXjvR63K0FKfU(137438953609) account: UIAutoTest] [CreateAvatarDBCallBack]createEntityFromDB error, err = create entity from db failed, can not find entity, aSAuWHcaoSpEJH2e
```
定位这种问题，一般就是Property格式变了，直接去dbmgr.log上去去查
```
2025-12-26 11:33:50,910641 - dbmgr - 881332 - ERROR - [doraemon] entity_bson_convertor.hpp:73 - bson_to_msgpack error, prop type is vList, bson type must be k_array[k_array * 2]

2025-12-26 11:33:50,910724 - dbmgr - 881332 - ERROR - [doraemon] entity_bson_convertor.cpp:373 - entity_bson_to_msgpack convert failed -> key [HUDSettings]

2025-12-26 11:33:50,910730 - dbmgr - 881332 - ERROR - [doraemon] op_mongo_create_entity.cpp:107 - create from db, but convert BSON to msgpack failed!!!!!! , db: zhangtiancheng-ui-perf_1, col: AvatarActor, entity id: aSAuWHcaoSpEJH2e

2025-12-26 11:35:52,914219 - dbmgr - 881331 - ERROR - [doraemon] entity_bson_convertor.hpp:73 - bson_to_msgpack error, prop type is vList, bson type must be k_array[k_array * 2]
```
能快速定位到是什么属性变了，而且其实一般不用管。新号正常就行。

# 30
#想法 
为什么我们的logic->logic都要走router转发，既然都是全连接网状拓扑，为什么不直接logic和logic直连，例如一些不动的对象，例如callService，其实不需要走router吧。