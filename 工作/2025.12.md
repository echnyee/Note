# 5
#系统设计  #分布式 #多进程
## [[分布式]]
# 24
#mongo #数据库
## mongo的分批加载
### batchsize
db.col.find({ score: { $gt: 100 } }).batchSize(100)
这个命令我理解会返回一个流控制器cursor
此时每次获取数据会被batchSize(100)限制，也就是流上限会被限制
MongoCursor\<Document\> cursor =
    collection.find(gt("score", 100))
              .batchSize(100)
              .iterator();

while (cursor.hasNext()) {
    Document doc = cursor.next();
}
类似这种处理
如果直接find，mongo也会有某种意义的上限，例如单个文档16mb
但这时 client buffer 可能瞬间暴涨
所以find+batchSize比find应该永远是更安全的
只是数据量不大的情况下，直接用find也没问题
不过这个也有问题，就是没法中断，不能说我先读了一些，然后进程去做点别的业务，等会儿再回来继续
### Skip
另外一个是skip，这个是分页加载，拿数据的时候跳掉前面的100个
db.collection
  .find({})
  .skip(100)
  .limit(10)
这个其实不太用，数据量大的时候会很慢
### 人工游标
然后我当时用的就是，人工游标，通过score + \_id，缩小了范围，也消除了重复性，也可以等会儿回来继续处理。
# 25
#锁 #多线程
n++，在操作系统层面，会读取内存数据到寄存器，寄存器+1，再写回内存
用锁，可以避免多线程的竞争，让每次只有一个线程在做这个操作
atomic感觉有些类似，不过是操作系统层面的实现，可以让上面这3步变成一次操作，
2个atomic之间会互斥，不能同时进行。
mutex的唤醒有2种机制
一种自旋，不停的试，知道获取到锁为止
一种是futex等待队列，线程进入到内核态等待，同时放入一个mutex对应的等待队列中，这样后续unlock的时候知道要唤醒谁
现实中很可能是混合的，先自旋一会儿，不行就进入内核态等待
条件变量是一个通知，就是线程A在等待条件变量满足条件，例如dataReady从false变成true
线程B会去写dataReady，写完之后唤醒线程A