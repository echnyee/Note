# 13
## 自动应答机器人
#想法 #AI 
是否可以考虑训练一个问答机器人，现在负责的通用系统比较多，例如背包道具，Trigger&Condition，在其他同学询问的时候可以直接通过AI给他们解答。但是这样做会不会把自己做掉，因为大家会发现，不需要你了。
#系统设计
## [[不停服维护方案（AB服轮转维护）]]
# 14
#小技巧
## [[百度网盘下载方法]]
# 15
#系统设计 
##  [[实时存档]]
#系统设计 
## [[Entity Term]]
# 18
#系统设计 
## [[Mailbox]]
# 19
#小技巧 
## Elastic搜索方法
注意，下面这行里面有反斜杠，但是这个笔记默认显示好像就把他置灰了，直接选中能看出来
"\"actionName\":\"rolelogin\""
"Account.lua:" and "nickname repeat"
#登录 #debug
## debug压测登录失败问题
"Account.lua:" and "ReqLogin" 可以查看Account有多少登录请求
"\"actionName\":\"login\"" 可以查有多少Account登录成功
"Account.lua:" and "ReqCreateRole" 可以查看有多少请求创角的请求（如果没有角色的Account创角会直接进入游戏）
"Account.lua:" and "ReqStartGame" 可以查看有多少选角后进入游戏的请求（如果有角色选角后走的就是这个接口）
上面两者相加就是尝试创建AvatarActor并进入场景的数量
"\"actionName\":\"rolelogin\"" 可以查有多少Avatar登录成功
#登录 #现有实现 #登出
Avatar的Logout会触发离开场景，具体的逻辑在这里，后面就是引擎逻辑了，在离开场景后由于也不在有aoi了，马上会通知客户端销毁aoi内的客户端对象，例如NpcActor
```lua
function ActorBase:onFini()  
    self:LeaveSpace(Enum.ELeaveSpaceReason.ActorFinish)  
end

function EntityBase:EntityLeaveSpace()  
    self.Space = nil  
    self:leaveSpace(true)  
end
```
返回选角界面，也会触发Logout，也一样会触发上面离开场景的流程，另外会在登出的最后阶段，存盘结束后通知客户端开始选角，也就是Logout成功再进入选角界面，NotifyAvatarLogoutEnd
```lua
function AvatarActor:FiniPersistentCB(res)  
    if res == true then  
        self:logInfoFmt("FiniPersistentCB %v", res)  
        self._isDestroying = true  
        self:CallService("OnlineService", "NotifyAvatarLogoutEnd", self.accountID, nil):Args(self.accountID, self.id, _script.process_id, false, self.bServiceRemoved)  
        if self.ClusterClosing then  
            self:logInfoFmt("AvatarActor:%s onClusterClosing Finish", self.id)  
            self:safeCall(self.ConfirmClusterClosing)  
        end  
        local processAddSaveAndShutDownCheckTimer = self.processAddSaveAndShutDownCheckTimer  
        if processAddSaveAndShutDownCheckTimer then  
            Game.Process:delTimer(processAddSaveAndShutDownCheckTimer)  
        end  
        self:destroy() 
end
```

# 27
#想法  #Property
现在代码里面Property的机制，会有3个反直觉的地方
1. 对于复杂结构Property的赋值之后，右值如果原来是一个普通的table，会变成和Property一样的结构
![[Pasted image 20251127105135.png]]
2. 对于复杂结构Property的赋值之后，默认值并不会生效，但是如果玩家重登之后，如果原来是nil空值的则都会变成默认值，例如这里如果autoExploreProgress不放在初始table里面，那他就是nil，但是重登之后又变成了0
```lua
self.partners[partnerID] = {  
    starLevel = cfg.InitStar,  
    fragmentCount = fragmentCount,  
    bNew = true,  
    appearanceID = 0,  
    autoExploreProgress = 0,  
}

<SECRET_PARTNER Type="tuple">  
    <starLevel Type="int" Default="1" Persistent="true" Flags="OWN_CLIENT"/>         <!-- 星级，从小到大，最低为1，代表1星，但会有三星+1，所以此数字不直接对应星数 -->  
    <fragmentCount Type="int" Default="0" Persistent="true" Flags="OWN_CLIENT"/>     <!-- 碎片数量 -->  
    <bNew Type="BOOL" Default="true" Persistent="true" Flags="OWN_CLIENT"/>          <!-- 是否是新获得的秘偶，客户端红点用 -->  
    <appearanceID Type="int" Default="0" Persistent="true" Flags="OWN_CLIENT"/>      <!-- 外观ID -->  
    <shapeInfo Type="SHAPE_INFO" Default="nil" Persistent="true" Flags="ALL_INITIAL_ONLY"/>      <!-- 幻形数据，仅人形秘偶有 -->  
    <autoExploreProgress Type="int" Default="0" Persistent="true" Flags="OWN_CLIENT"/>     <!-- 自动探索进度 -->  
</SECRET_PARTNER>
```
3. 和2相关，这个默认值不存盘的机制真的是一个好设计么，现在就会出现内存中和db中的数据不一致的情况，而且在登录后Property的值是会变的，这也比较奇怪



