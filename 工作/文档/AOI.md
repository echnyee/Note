## AOI整体流程
### borad phase
粗选阶段，快速剪枝，缩小需要遍历的对象范围，例如九宫格就是根据xy坐标快速定位，十字链表则使用x轴的链表先过滤，然后再用y轴的链表过滤，快速减少对象范围。
### user-defined filter
用户定义的一些过滤手段，例如根据对象类型判断是否需要进行进一步的操作，如果不是玩家怪物，那么他的interest的部分可能就可以不用管，如果是同一个group下的，例如都是npc，那么他们互相之间可能也不需要care
### narrow phase
精细检测，一般视野范围是圆形，需要通过sqrt来计算距离，不过这个一般性能消耗其实也不高。只是一个平方计算。性能消耗比较大的是对象的遍历，也会涉及到内存里的cache miss，一般来说，用vector来存格子信息是最优的，因为遍历或者说查询的量级会高于修改的量级。
### 一次 AOI 更新的真实成本排序：
1️⃣ **扫描对象数量**  
2️⃣ cache miss / 内存访问  
3️⃣ Enter / Leave 逻辑  
4️⃣ 距离判断（几乎可以忽略）

### 并发
grid方式的并发友好一些，可以按照格子级别去锁
十字链表锁的力度会很大，因为一个场景下大家都在用2个相同的链表

## 十字链表
### 十字链表法的核心思想

**把 2D 问题拆成两个 1D 问题**：
- 一条 **X 轴有序链表**
- 一条 **Y 轴有序链表**
- 每个对象 **同时挂在 X 链表 和 Y 链表上**

所以叫 **“十字链表”**（一个节点有横向和纵向两条链）。