概述

传统的网游服务器，为了缓解db的压力，一般会让每个entity间隔一段较长的时间（比如15分钟）才进行一次全量的存盘操作。这个较大的时间间隔带来了一个问题，就是回档。如果玩家在这15分钟内获得了好东西或者消费了rmb，在还没存盘之前服务器挂了，玩家是会闹翻天的。我们以前一般会在玩家获得了贵重物品或者进行了重要操作之后，主动进行一次存盘，这个就需要玩法重度参与存盘的策略，属于没有办法的办法。

减少存盘的时间间隔，db受不了，增加存盘的时间间隔，玩家受不了。为了解决这个问题，大家开始纷纷研究“实时存盘”功能。据我所了解的，大致有下面几种：

1. 存盘时间有一定的间隔，每次存盘属性修改都会记录一条修改log。游戏进程非正常退出后，重启进程时会跑一个自动扫log来修正存盘数据的脚本，让存盘数据能追到游戏进程刚退前的状态。就像数据库的binlog一样。
    
2. 每次修改存盘属性都执行一个修改这个属性的db操作，可谓“真•实时存盘”。带给db的压力可想而知。
    
3. 在dbmgr存一份entity存盘属性的快照，在entity的存盘属性进行修改时，会发一个rpc给dbmgr增量同步这个属性，让快照保持和entity一致。当游戏进程挂了时，db会用这个快照进行存盘；当dbmgr挂了时，游戏进程可以再选个新的dbmgr，在上面重建entity的快照。然后定期把dbmgr的缓存存盘即可。这个方案的优点是开销小，有个小缺点是万一游戏进程和dbmgr同时挂了，entity数据就回档了。所以我们启用实时存盘后，引擎会自动保证logic和dbmgr在不同的机器上。
    

我们引擎采用的是第3种方案。