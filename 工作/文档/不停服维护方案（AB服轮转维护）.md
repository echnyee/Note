# 基本介绍

部署两套独立但共享数据库的服务器集群，并通过轮转流程实现版本切换，使维护过程对玩家几乎无感知。（开始轮转后不在玩法中的玩家会被指引进行下线和重新登录，即可进入到维护后的新服进行正常的游戏）

# 优势

玩家体验好，不会有停服维护几个小时进不了游戏的情况，维护期间依然可以进行游戏

维护时间友好，不再依赖低峰时段（如凌晨）

修复线上问题覆盖面广， 如果出现一些难以热更修复的问题可以通过轮转维护进行修复

# 缺点

开发与运维复杂度提升 开发有两方面的成本，一个是改造成本，这是一次性的。另外会有长期成本，由于引入不停服维护的概念，代码复杂度会提高，在设计系统时需要考虑在轮转维护阶段是否会有问题，当然如果轮转维护的通用逻辑设计合理，许多系统可以对轮转维护无感。

扫档限制，走轮转维护的话没法进行扫档处理，需要扫档的话仍然需要停服维护。

# 方案介绍

本方案采用 AB服轮转架构。系统包含两套逻辑节点（Router、Logic、DBMgr、Cluster），共用同一数据库实例以保证数据的一致性。新老服之间可以采用hub集群的形式进行互通。

在轮转期间（即新老集群并行运行阶段），老服先进入功能屏蔽状态，待新服完成数据加载后，引导玩家重新登录至新服。（具体见下文的流转流程）而新老服在数据层面需要尽可能的实现互斥。

# 轮转流程

![](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAA2f9NjlOd09AkhF8Ao6z0h:7784351481126598587fcAA2f9NjlOd09AkhF8Ao6z0h:1763041913200)

轮转维护大致可以分为四个阶段

## 阶段1

- 新服启动但是但禁用数据持久化 ，老服无任何影响。
    
- qa在新服进行相关测试
    

## 阶段2

- 新服测试完毕，可以开始进行轮转维护，通知老服开始维护，
    
- 老服屏蔽大部分Service功能，此时会对玩家产生影响，发现部分功能不可用，例如无法加好友，无法创建公会，无法新开副本等，已经在一些副本玩法中的不影响。
    
- 然后老服大部分Service进行存盘，完成存盘后通知新服，新服从数据库中加载数据，完成后新服功能完备，数据也是最新，更新服务器指向，之后新登录的客户端会进入新服，且可以在新服正常游戏。
    
- 这个阶段要尽量把时间缩短，因为这个阶段会出现玩家在老服功能受限，并且还不能登录新服的情况。
    

## 阶段3

- 新服读取数据完成后，可以对外服务，此时已经修改客户端指向，玩家的新登录会进入新服。
    
- 部分玩家依然滞留在老服，此时老服的功能会受限，一些获取类的功能可以考虑继续开放，新开副本，以及一些会修改非玩家数据的服务需要屏蔽。
    

## 阶段4

- 在阶段3等待一段时间后（可以以时间较长的一类副本玩法作为时间阈值）保证基本所有玩家都不在进行一些玩法，而只是待在主城还未下线，进行强制下线操作。
    
- 确保数据落地后关闭旧服节点，轮转流程结束。
    

  

# 数据互斥细节

## 玩家

玩家数据的互斥通过限制玩家同时在新老服登录完成。在轮转过程中，玩家登录到新服时，会触发去老服踢自己下线的操作。这里一般有两种策略，At Least Once和At Most Once。

这里会考虑一种结合的方案，新服发送rpc去老服踢自己下线，期望收到回复，正常回复后继续进行登录流程，如果超时没有收到回复则重传rpc。超过一定次数后也允许在新服进行登录，此时通过玩家的term来进行数据的保护，老服即使有玩家对象也无法进行有效存盘操作。

## service

可以分为

在老服可以屏蔽的service

新老服需要进行数据上的互斥，在阶段2开始后，老服屏蔽会修改数据的各类操作，然后进行存盘操作。存盘结束后在新服进行数据的加载（Property及自主管理的数据库数据）

无法在老服完全屏蔽的Service

由于在开始轮转维护时不能直接踢走老服的玩家，他们仍然可能在进行一些玩法。此时老服仍然可能触发结算流程。如果结算流程只影响玩家数据，则不会有太大影响，如果会涉及到其他数据，例如排行榜（不同玩家之间数据的集合）需要额外进行处理。尽量控制这部分Service的比例，一般也很少。

大致的方案为，在阶段2开始轮转时，缓存修改的请求，在新服读取数据结束后进行发送，在阶段3新老服仍然共存时，老服需要把产生的数据修改类的请求转发到新服的Service上进行统一处理。而在老服查询数据的时候需要接受获取到的数据不是最新的或者干脆屏蔽。

## redis

目前项目中使用redis的场景还较少，也可以将redis中的数据区分为是玩家维度的还是非玩家维度的数据，依然可以使用相同的一套redis集群，玩家数据可以通过玩家的互斥天然的支持轮转维护，而其他数据如果有service管理也可以遵循和上面service一样的处理模式

# 风险&可能的解决方案

## 存盘控制

在轮转开始时会出现所有Service进行存盘的操作，需要梳理压测一遍service需要存盘的量级，看是否需要做一些性能上的削峰处理，例如分批落地。

## 新服登录时没有收到老服踢掉自己的成功回调

上面玩家互斥环节也提到了，首先还是期望收到回复正常进行登录，如果超时后依然进行新服的登录，主要考虑的还是不要影响玩家的登录流程，通过term去保证能保存最新的数据。

## 轮转流程中出错后如何恢复

阶段1 出错，此时还未开始轮转，如果新服出现问题比较好处理，基本可以比较自由的操作，重启，更新代码都可以。

阶段2 出错，此时的处理策略为恢复老服，因为客户端的指向仍然为老服，而新服也没有ready，停止轮转，将老服屏蔽的功能重新开放。待问题排查处理结束后再进行轮转维护。

阶段3 出错，此时会优先考虑尽快使用新服，可以根据问题的严重程度判断是否要加速阶段3，踢掉老服玩家，将玩家都指引到新服。或者老服人数较多没法踢则是否有一些快速的热更手段。

阶段4，此时是在老服踢玩家下线的流程了，一般不会有影响较大的问题出现，与轮转流程也不会有太大的关联了，按照正常的问题去处理就行了。可能会出现踢下线失败，或者数据落地的问题，此时可以考虑延长次阶段的时间，把仍然在线的玩家数据保存成功后关服。或者调查后发现影响玩家较少，数据存盘也影响较小的话也可以直接关服。（玩家之前的定时存盘已经有了比较新的数据，或者已经在新服登录了，或者后续再排查少量玩家的数据问题）

## 会被非玩家来源修改的玩家数据如何处理

轮转过程中玩家存盘是不限制的，玩家的互斥主要依赖于玩家entity的互斥（新老服只能在一处登录），但是也可能有少部分需求会出现非玩家来源修改玩家属性的情况。例如好友的申请列表。此时即使玩家entity互斥了，依然有可能会出现新老服都在修改玩家属性的情况。此时需要分析这些数据是否本身就支持并行修改，例如新服修改db后，老服玩家如果存盘的话，会不会把数据刷掉。此类数据需要单独梳理不过预计应该很少。