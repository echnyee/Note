### Entity Term值如何产生

1. 从数据库中创建的Entity
    

主要指的是玩家的Avatar或者一些会落地状态数据到数据库的Stub Entity，对于这类的Entity每一次从数据库创建的时候都自增一次其Term值即可，并读取修改之后的值，对应Python大概为如下的查询语句：

![[Pasted image 20251118112604.png]]

Entity的Term值依赖于数据库的原子自增保证不会出现重复的情况，MongoDB的规范指出，对于单Document的多操作是保证原子的，可以参见：[https://docs.mongodb.com/manual/core/write-operations-atomicity/](https://docs.mongodb.com/manual/core/write-operations-atomicity/)

  

2. 一些不需要从数据库中创建，但生命周期具有延续性的Entity
    

这类主要是对应的一些不需要落地数据的Stub，他们的状态完全在内存中，只要服务器没有关机它就必然存在提供一些全局的服务，如果因为异常情况导致其下线了，框架需要通过一定的机制再将其调度创建出来。对于这一类型的Entity，比较简单的方法也是可以通过MongoDB为其分配一个自增的Term值即可。

  

3. 生命周期无延续性，不需要存盘也不需要恢复的临时Entity
    

这类的Entity在游戏服务器中也比较常见，比如说创生物，无持续状态的Entity例如Battle Allocator等，他们每次创建Entity ID都是随机生成的，对于这类给他们的Term值赋值一个特殊的值作为标记即可，例如赋值为0。

DB进程在处理存盘请求的逻辑：

1. Term值大于等于数据库中的值有效，如果小于，则无效，不能存盘，可以存到备库，并提醒Entity其已经失效。（出现大于数据库中Term的值的情况应该不会有，除非之前出现过数据库异常）通过单doucument的原子操作实现。
    
2. 在Term值符合的前提下，Index大于数据库中的Index值有效，可以执行存盘，否则无效，这种情况下对于无效的存盘请求直接返回成功即可。通过单document的原子操作实现。
    
3. DB进程可以判断当前自己的存盘负载，如果觉得存盘负载过高，待执行任务很多，可以直接随机丢弃存盘任务。
    
  
![[Pasted image 20251115171255.png]]


如上图，现在Entity在发送存盘请求的时候不再是发送后不管，而是需要建立一个存盘请求队列，Entity的处理逻辑如下：

1. 每次产生存盘请求的时候，需要对存盘index自增，所以请求本身带有当前的存盘index。
    
2. 请求先置入存盘请求队列中，如果该在该请求之前没有别的待确认请求了，那么该请求接下来可以发送给任意一个DBManager进程。（当然实际情况可以有一定的逻辑选择发送给谁，这里重点提示任意一个只是为了说明这种情况下不再有定死的绑定关系）
    
3. 存盘请求必须要等到DB进程确认回复之后才能将其从请求队列中移除，然后再发送可能存在的待发送请求（这对实现纯增量存盘很重要）。
    
4. 存盘请求等待超时之后，请求需要再重发给任意一个DBManager进程，并继续等待回复确认。
    

新增全量存盘的时候，如果前面还有挂起的待确认存盘请求，可以直接将这些请求全部移除掉，逻辑上可以认为这些请求都处理成功了，然后接下来只需要处理这个全量存盘即可。

通过上面的改造最后我们得到了一个结果：对于Entity的存盘功能，DBManager对Entity来说变成了一个无状态的服务，相关请求的消息可以任意的发送与重传，同时对entity的迁移也更友好。这种机制下容灾，负载均衡，保序这些问题都已经不再存在了，同时可以简化状态机的设计，中途的定期存盘不再需要交互式的实现，去掉相关的异步状态挂起。