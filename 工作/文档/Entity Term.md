DB进程在处理存盘请求的逻辑：

1. Term值大于等于数据库中的值有效，如果小于，则无效，不能存盘，可以存到备库，并提醒Entity其已经失效。（出现大于数据库中Term的值的情况应该不会有，除非之前出现过数据库异常）通过单doucument的原子操作实现。
    
2. 在Term值符合的前提下，Index大于数据库中的Index值有效，可以执行存盘，否则无效，这种情况下对于无效的存盘请求直接返回成功即可。通过单document的原子操作实现。
    
3. DB进程可以判断当前自己的存盘负载，如果觉得存盘负载过高，待执行任务很多，可以直接随机丢弃存盘任务。
    
  
![[Pasted image 20251115171255.png]]


如上图，现在Entity在发送存盘请求的时候不再是发送后不管，而是需要建立一个存盘请求队列，Entity的处理逻辑如下：

1. 每次产生存盘请求的时候，需要对存盘index自增，所以请求本身带有当前的存盘index。
    
2. 请求先置入存盘请求队列中，如果该在该请求之前没有别的待确认请求了，那么该请求接下来可以发送给任意一个DBManager进程。（当然实际情况可以有一定的逻辑选择发送给谁，这里重点提示任意一个只是为了说明这种情况下不再有定死的绑定关系）
    
3. 存盘请求必须要等到DB进程确认回复之后才能将其从请求队列中移除，然后再发送可能存在的待发送请求（这对实现纯增量存盘很重要）。
    
4. 存盘请求等待超时之后，请求需要再重发给任意一个DBManager进程，并继续等待回复确认。
    

新增全量存盘的时候，如果前面还有挂起的待确认存盘请求，可以直接将这些请求全部移除掉，逻辑上可以认为这些请求都处理成功了，然后接下来只需要处理这个全量存盘即可。

通过上面的改造最后我们得到了一个结果：对于Entity的存盘功能，DBManager对Entity来说变成了一个无状态的服务，相关请求的消息可以任意的发送与重传，同时对entity的迁移也更友好。这种机制下容灾，负载均衡，保序这些问题都已经不再存在了，同时可以简化状态机的设计，中途的定期存盘不再需要交互式的实现，去掉相关的异步状态挂起。